<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LLM Debate</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
  @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=IBM+Plex+Sans:wght@400;500;600&display=swap');

  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --paper: #FFFCF0; --ink: #2D2B28; --muted: #6F6E69;
    --line: #DAD8CE; --panel: #F2F0E5;
    --blue: #205EA6; --cyan: #24837B; --green: #66800B;
    --orange: #BC5215; --red: #AF3029; --purple: #5E409D;
    --yellow: #AD8301; --magenta: #A02F6F;
    --radius: 4px;
    --thinking-bg: #F7F5E8;
  }

  @media (prefers-color-scheme: dark) {
    :root {
      --paper: #100F0F; --ink: #CECDC3; --muted: #878580;
      --line: #403E3C; --panel: #1C1B1A;
      --blue: #4385BE; --cyan: #3AA99F; --green: #879A39;
      --orange: #DA702C; --red: #D14D41; --purple: #8B7EC8;
      --yellow: #D0A215; --magenta: #CE5D97;
      --thinking-bg: #1A1918;
    }
  }

  html, body {
    height: 100%;
    font: 14px/1.6 'IBM Plex Sans', -apple-system, sans-serif;
    background: var(--paper);
    color: var(--ink);
  }

  .container {
    display: flex;
    flex-direction: column;
    height: 100%;
    padding: 16px;
    gap: 16px;
  }

  /* Header */
  header {
    display: flex;
    gap: 16px;
    align-items: center;
    flex-shrink: 0;
    flex-wrap: wrap;
  }

  header h1 {
    font-size: 1.25em;
    font-weight: 600;
    color: var(--ink);
    white-space: nowrap;
    font-family: 'IBM Plex Mono', monospace;
  }

  .prompt-form {
    display: flex;
    flex: 1;
    gap: 12px;
    min-width: 300px;
  }

  .prompt-input {
    flex: 1;
    padding: 12px 16px;
    font: inherit;
    font-size: 15px;
    border: 2px solid var(--line);
    border-radius: var(--radius);
    background: var(--panel);
    color: var(--ink);
    min-width: 200px;
    transition: border-color 0.2s;
  }

  .prompt-input:focus {
    outline: none;
    border-color: var(--blue);
  }

  .prompt-input:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .submit-btn {
    padding: 12px 24px;
    font: inherit;
    font-weight: 600;
    border: none;
    border-radius: var(--radius);
    background: var(--blue);
    color: #fff;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
  }

  .submit-btn:hover:not(:disabled) {
    background: var(--cyan);
    transform: translateY(-1px);
  }

  .submit-btn:disabled {
    background: var(--muted);
    cursor: not-allowed;
  }

  /* Status bar */
  .status-bar {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 16px;
    background: var(--panel);
    border: 1px solid var(--line);
    border-radius: var(--radius);
    font-size: 0.9em;
    color: var(--muted);
    flex-shrink: 0;
  }

  .status-bar.error {
    border-color: var(--red);
    color: var(--red);
    background: rgba(175, 48, 41, 0.05);
  }

  .status-bar.success {
    border-color: var(--green);
    color: var(--green);
    background: rgba(102, 128, 11, 0.05);
  }

  .status-text { flex: 1; }

  .connection-indicator {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--muted);
    flex-shrink: 0;
  }

  .connection-indicator.connected { background: var(--green); }
  .connection-indicator.disconnected { background: var(--red); }

  /* Main content: 3 columns */
  .columns {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
    flex: 1;
    min-height: 0;
  }

  @media (max-width: 1200px) {
    .columns {
      grid-template-columns: 1fr;
      grid-template-rows: repeat(3, 1fr);
    }
  }

  /* Panes */
  .pane {
    display: flex;
    flex-direction: column;
    border: 2px solid var(--line);
    border-radius: var(--radius);
    background: var(--panel);
    overflow: hidden;
    min-height: 0;
    transition: border-color 0.3s, box-shadow 0.3s;
  }

  .pane.streaming {
    border-color: var(--cyan);
    box-shadow: 0 0 0 3px rgba(36, 131, 123, 0.1);
  }

  .pane.complete {
    border-color: var(--green);
  }

  .pane.error {
    border-color: var(--red);
  }

  .pane-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    border-bottom: 1px solid var(--line);
    background: var(--paper);
    flex-shrink: 0;
    gap: 12px;
  }

  .pane-title {
    font-weight: 600;
    font-size: 1em;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-family: 'IBM Plex Mono', monospace;
  }

  .pane[data-source="claude"] .pane-title { color: var(--orange); }
  .pane[data-source="chatgpt"] .pane-title { color: var(--green); }
  .pane[data-source="gemini"] .pane-title { color: var(--blue); }

  .pane-meta {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .pane-status {
    font-size: 0.8em;
    font-family: 'IBM Plex Mono', monospace;
    color: var(--muted);
    padding: 4px 8px;
    border-radius: var(--radius);
    background: var(--panel);
  }

  .pane-status.streaming {
    color: var(--cyan);
    background: rgba(36, 131, 123, 0.1);
  }

  .pane-status.complete {
    color: var(--green);
    background: rgba(102, 128, 11, 0.1);
  }

  .pane-status.error {
    color: var(--red);
    background: rgba(175, 48, 41, 0.1);
  }

  .pane-content {
    flex: 1;
    padding: 16px;
    overflow-y: auto;
    font-size: 0.95em;
    line-height: 1.7;
  }

  .pane-content.empty .response-content:empty::before {
    content: "Waiting for response...";
    color: var(--muted);
    font-style: italic;
  }

  /* Hide empty message when thinking indicator is active */
  .pane-content .thinking-indicator.active ~ .response-content:empty::before {
    display: none;
  }

  /* Active Thinking Indicator (Claude-style) */
  .thinking-indicator {
    display: none;
    margin-bottom: 16px;
    padding: 16px;
    border-radius: var(--radius);
    background: linear-gradient(135deg, var(--thinking-bg) 0%, var(--panel) 100%);
    border: 1px solid var(--line);
    position: relative;
    overflow: hidden;
  }

  .thinking-indicator.active {
    display: block;
  }

  .thinking-indicator::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 200%;
    height: 100%;
    background: linear-gradient(
      90deg,
      transparent 0%,
      rgba(94, 64, 157, 0.08) 25%,
      rgba(94, 64, 157, 0.15) 50%,
      rgba(94, 64, 157, 0.08) 75%,
      transparent 100%
    );
    animation: shimmer 2s ease-in-out infinite;
  }

  @keyframes shimmer {
    0% { transform: translateX(0); }
    100% { transform: translateX(50%); }
  }

  .thinking-indicator-header {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 0.9em;
    font-weight: 500;
    color: var(--purple);
    font-family: 'IBM Plex Mono', monospace;
    position: relative;
    z-index: 1;
  }

  .thinking-sparkles {
    display: flex;
    gap: 3px;
    font-size: 14px;
  }

  @keyframes sparkle {
    0%, 100% { opacity: 0.3; transform: scale(0.8); }
    50% { opacity: 1; transform: scale(1.1); }
  }

  .thinking-sparkles span {
    animation: sparkle 1.2s ease-in-out infinite;
    color: var(--purple);
  }

  .thinking-sparkles span:nth-child(2) { animation-delay: 0.15s; }
  .thinking-sparkles span:nth-child(3) { animation-delay: 0.3s; }

  .thinking-dots {
    display: flex;
    gap: 4px;
    margin-left: 4px;
  }

  .thinking-dots span {
    width: 6px;
    height: 6px;
    background: var(--purple);
    border-radius: 50%;
    animation: dotPulse 1.4s ease-in-out infinite;
  }

  .thinking-dots span:nth-child(2) { animation-delay: 0.2s; }
  .thinking-dots span:nth-child(3) { animation-delay: 0.4s; }

  @keyframes dotPulse {
    0%, 80%, 100% { opacity: 0.3; transform: scale(0.8); }
    40% { opacity: 1; transform: scale(1); }
  }

  .thinking-preview {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid var(--line);
    font-size: 0.85em;
    color: var(--muted);
    line-height: 1.5;
    max-height: 120px;
    overflow: hidden;
    position: relative;
    z-index: 1;
    font-family: 'IBM Plex Mono', monospace;
  }

  .thinking-preview::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 40px;
    background: linear-gradient(transparent, var(--thinking-bg));
    pointer-events: none;
  }

  /* Completed Thinking Block (collapsible) */
  .thinking-block {
    margin: 0 0 16px 0;
    border-radius: var(--radius);
    background: var(--thinking-bg);
    border: 1px solid var(--line);
    overflow: hidden;
  }

  .thinking-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px 14px;
    cursor: pointer;
    user-select: none;
    font-size: 0.85em;
    color: var(--muted);
    font-family: 'IBM Plex Mono', monospace;
    transition: background 0.2s;
  }

  .thinking-header:hover {
    background: rgba(94, 64, 157, 0.05);
  }

  .thinking-header-text {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .thinking-icon {
    width: 16px;
    height: 16px;
    transition: transform 0.3s ease;
    color: var(--purple);
  }

  .thinking-block.collapsed .thinking-icon {
    transform: rotate(-90deg);
  }

  .thinking-label {
    color: var(--purple);
    font-weight: 500;
  }

  .thinking-duration {
    color: var(--muted);
    font-size: 0.9em;
  }

  .thinking-content {
    padding: 0 14px 14px;
    font-size: 0.88em;
    color: var(--muted);
    line-height: 1.6;
    max-height: 400px;
    overflow-y: auto;
    transition: max-height 0.3s ease, padding 0.3s ease, opacity 0.3s ease;
  }

  .thinking-block.collapsed .thinking-content {
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
    opacity: 0;
  }

  /* Response content area */
  .response-content {
    /* Main response after thinking */
  }

  /* Markdown styling */
  .pane-content h1, .pane-content h2, .pane-content h3 {
    margin: 1.2em 0 0.6em;
    font-weight: 600;
    line-height: 1.3;
  }

  .pane-content h1:first-child,
  .pane-content h2:first-child,
  .pane-content h3:first-child {
    margin-top: 0;
  }

  .pane-content h1 { font-size: 1.3em; }
  .pane-content h2 { font-size: 1.15em; }
  .pane-content h3 { font-size: 1.05em; }

  .pane-content p { margin: 0.6em 0; }

  .pane-content ul, .pane-content ol {
    margin: 0.6em 0 0.6em 1.5em;
  }

  .pane-content li { margin: 0.3em 0; }

  .pane-content code {
    font-family: 'IBM Plex Mono', monospace;
    background: var(--paper);
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 0.9em;
  }

  .pane-content pre {
    background: var(--paper);
    padding: 14px;
    border-radius: var(--radius);
    overflow-x: auto;
    margin: 0.8em 0;
    border: 1px solid var(--line);
  }

  .pane-content pre code {
    background: none;
    padding: 0;
  }

  .pane-content blockquote {
    border-left: 3px solid var(--blue);
    padding-left: 14px;
    margin: 0.8em 0;
    color: var(--muted);
  }

  /* Copy button */
  .copy-btn {
    padding: 6px 10px;
    font: inherit;
    font-size: 0.8em;
    font-family: 'IBM Plex Mono', monospace;
    border: 1px solid var(--line);
    border-radius: var(--radius);
    background: var(--paper);
    color: var(--muted);
    cursor: pointer;
    transition: all 0.2s;
  }

  .copy-btn:hover {
    border-color: var(--blue);
    color: var(--blue);
  }

  .copy-btn.copied {
    border-color: var(--green);
    color: var(--green);
  }

  /* Triage overlay */
  .triage-overlay {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    max-height: 70vh;
    background: var(--paper);
    border-top: 2px solid var(--purple);
    box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.15);
    border-radius: 16px 16px 0 0;
    transform: translateY(calc(100% - 56px));
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 1000;
    display: flex;
    flex-direction: column;
  }

  .triage-overlay.expanded {
    transform: translateY(0);
  }

  .triage-handle {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 20px;
    cursor: pointer;
    user-select: none;
    background: var(--panel);
    border-radius: 16px 16px 0 0;
    flex-shrink: 0;
  }

  .triage-handle:hover {
    background: var(--line);
  }

  .triage-title {
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 600;
    font-family: 'IBM Plex Mono', monospace;
    color: var(--purple);
    font-size: 1em;
  }

  .triage-status {
    font-size: 0.85em;
    color: var(--muted);
    font-family: 'IBM Plex Mono', monospace;
  }

  .triage-toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 14px;
    border: 1px solid var(--purple);
    border-radius: var(--radius);
    background: transparent;
    color: var(--purple);
    font: inherit;
    font-size: 0.85em;
    cursor: pointer;
    transition: all 0.2s;
  }

  .triage-toggle:hover {
    background: var(--purple);
    color: #fff;
  }

  .triage-toggle svg {
    transition: transform 0.3s;
  }

  .triage-overlay.expanded .triage-toggle svg {
    transform: rotate(180deg);
  }

  .triage-content {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    font-size: 0.95em;
    line-height: 1.7;
  }

  .triage-content.empty .response-content:empty::before {
    content: "Unified analysis will appear here after all models respond...";
    color: var(--muted);
    font-style: italic;
  }

  .triage-content .thinking-indicator.active ~ .response-content:empty::before {
    display: none;
  }

  .triage-actions {
    display: flex;
    gap: 10px;
    padding: 14px 20px;
    border-top: 1px solid var(--line);
    background: var(--panel);
    flex-shrink: 0;
  }

  /* Badge for new content */
  .new-badge {
    display: none;
    padding: 2px 8px;
    border-radius: 10px;
    background: var(--purple);
    color: #fff;
    font-size: 0.75em;
    font-weight: 600;
  }

  .triage-overlay.has-new:not(.expanded) .new-badge {
    display: inline-block;
    animation: pulse 1.5s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }

  /* Scrollbar */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  ::-webkit-scrollbar-track {
    background: transparent;
  }

  ::-webkit-scrollbar-thumb {
    background: var(--line);
    border-radius: 4px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background: var(--muted);
  }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>LLM Debate</h1>
      <form class="prompt-form" id="prompt-form">
        <input type="text" class="prompt-input" id="prompt-input"
               placeholder="Ask anything... responses from Claude, ChatGPT, and Gemini will be synthesized"
               autocomplete="off">
        <button type="submit" class="submit-btn" id="submit-btn">Debate</button>
      </form>
    </header>

    <div class="status-bar" id="status-bar">
      <span class="connection-indicator" id="connection-indicator"></span>
      <span class="status-text" id="status-text">Connecting...</span>
    </div>

    <div class="columns">
      <div class="pane" data-source="claude" id="pane-claude">
        <div class="pane-header">
          <span class="pane-title">Claude</span>
          <div class="pane-meta">
            <span class="pane-status" id="status-claude">idle</span>
            <button class="copy-btn" data-copy="claude">Copy</button>
          </div>
        </div>
        <div class="pane-content empty" id="content-claude">
          <div class="thinking-indicator" id="thinking-claude">
            <div class="thinking-indicator-header">
              <div class="thinking-sparkles"><span>✦</span><span>✦</span><span>✦</span></div>
              <span>Thinking</span>
              <div class="thinking-dots"><span></span><span></span><span></span></div>
            </div>
            <div class="thinking-preview" id="thinking-preview-claude"></div>
          </div>
          <div class="response-content" id="response-claude"></div>
        </div>
      </div>

      <div class="pane" data-source="chatgpt" id="pane-chatgpt">
        <div class="pane-header">
          <span class="pane-title">ChatGPT</span>
          <div class="pane-meta">
            <span class="pane-status" id="status-chatgpt">idle</span>
            <button class="copy-btn" data-copy="chatgpt">Copy</button>
          </div>
        </div>
        <div class="pane-content empty" id="content-chatgpt">
          <div class="thinking-indicator" id="thinking-chatgpt">
            <div class="thinking-indicator-header">
              <div class="thinking-sparkles"><span>✦</span><span>✦</span><span>✦</span></div>
              <span>Thinking</span>
              <div class="thinking-dots"><span></span><span></span><span></span></div>
            </div>
            <div class="thinking-preview" id="thinking-preview-chatgpt"></div>
          </div>
          <div class="response-content" id="response-chatgpt"></div>
        </div>
      </div>

      <div class="pane" data-source="gemini" id="pane-gemini">
        <div class="pane-header">
          <span class="pane-title">Gemini</span>
          <div class="pane-meta">
            <span class="pane-status" id="status-gemini">idle</span>
            <button class="copy-btn" data-copy="gemini">Copy</button>
          </div>
        </div>
        <div class="pane-content empty" id="content-gemini">
          <div class="thinking-indicator" id="thinking-gemini">
            <div class="thinking-indicator-header">
              <div class="thinking-sparkles"><span>✦</span><span>✦</span><span>✦</span></div>
              <span>Thinking</span>
              <div class="thinking-dots"><span></span><span></span><span></span></div>
            </div>
            <div class="thinking-preview" id="thinking-preview-gemini"></div>
          </div>
          <div class="response-content" id="response-gemini"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Floating Triage Overlay -->
  <div class="triage-overlay" id="triage-overlay">
    <div class="triage-handle" id="triage-handle">
      <div class="triage-title">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 2L2 7l10 5 10-5-10-5z"/>
          <path d="M2 17l10 5 10-5"/>
          <path d="M2 12l10 5 10-5"/>
        </svg>
        Unified Analysis
        <span class="new-badge">NEW</span>
      </div>
      <div style="display: flex; align-items: center; gap: 12px;">
        <span class="triage-status" id="status-synthesis">idle</span>
        <button class="triage-toggle" id="triage-toggle">
          <span>Expand</span>
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="18 15 12 9 6 15"/>
          </svg>
        </button>
      </div>
    </div>
    <div class="triage-content empty" id="content-synthesis">
      <div class="thinking-indicator" id="thinking-synthesis">
        <div class="thinking-indicator-header">
          <div class="thinking-sparkles"><span>✦</span><span>✦</span><span>✦</span></div>
          <span>Analyzing responses</span>
          <div class="thinking-dots"><span></span><span></span><span></span></div>
        </div>
        <div class="thinking-preview" id="thinking-preview-synthesis"></div>
      </div>
      <div class="response-content" id="response-synthesis"></div>
    </div>
    <div class="triage-actions">
      <button class="copy-btn" data-copy="synthesis">Copy Analysis</button>
    </div>
  </div>

  <script>
  // State
  const state = {
    ws: null,
    connected: false,
    debating: false,
    triageExpanded: false,
    responses: {
      claude: '',
      chatgpt: '',
      gemini: '',
      synthesis: ''
    },
    thinkingStartTime: {
      claude: null,
      chatgpt: null,
      gemini: null,
      synthesis: null
    },
    isStreaming: {
      claude: false,
      chatgpt: false,
      gemini: false,
      synthesis: false
    }
  };

  // Elements
  const form = document.getElementById('prompt-form');
  const input = document.getElementById('prompt-input');
  const submitBtn = document.getElementById('submit-btn');
  const statusText = document.getElementById('status-text');
  const connectionIndicator = document.getElementById('connection-indicator');
  const triageOverlay = document.getElementById('triage-overlay');
  const triageHandle = document.getElementById('triage-handle');
  const triageToggle = document.getElementById('triage-toggle');

  // Initialize marked
  marked.setOptions({
    breaks: true,
    gfm: true
  });

  // Triage overlay toggle
  triageHandle.addEventListener('click', toggleTriage);
  triageToggle.addEventListener('click', (e) => {
    e.stopPropagation();
    toggleTriage();
  });

  function toggleTriage() {
    state.triageExpanded = !state.triageExpanded;
    triageOverlay.classList.toggle('expanded', state.triageExpanded);
    triageOverlay.classList.remove('has-new');
    triageToggle.querySelector('span').textContent = state.triageExpanded ? 'Collapse' : 'Expand';
  }

  // Connect to WebSocket
  function connect() {
    const sessionId = crypto.randomUUID();
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/${sessionId}`;

    state.ws = new WebSocket(wsUrl);

    state.ws.onopen = () => {
      state.connected = true;
      setConnectionStatus(true);
      setStatus('Connected. Ready for debate.');
      enableForm(true);
    };

    state.ws.onclose = () => {
      state.connected = false;
      setConnectionStatus(false);
      setStatus('Disconnected. Reconnecting...', 'error');
      enableForm(false);
      setTimeout(connect, 2000);
    };

    state.ws.onerror = (err) => {
      console.error('WebSocket error:', err);
    };

    state.ws.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      handleMessage(msg);
    };
  }

  // Handle WebSocket messages
  function handleMessage(msg) {
    switch (msg.type) {
      case 'chunk':
        // Start thinking timer on first chunk
        if (!state.isStreaming[msg.source]) {
          state.isStreaming[msg.source] = true;
          state.thinkingStartTime[msg.source] = Date.now();
          showThinkingIndicator(msg.source, true);
        }

        appendContent(msg.source, msg.content);
        setSourceStatus(msg.source, 'streaming');

        // Show badge for new synthesis content
        if (msg.source === 'synthesis' && !state.triageExpanded) {
          triageOverlay.classList.add('has-new');
        }
        break;

      case 'complete':
        // Calculate thinking duration
        const duration = state.thinkingStartTime[msg.source]
          ? Math.round((Date.now() - state.thinkingStartTime[msg.source]) / 1000)
          : 0;

        state.isStreaming[msg.source] = false;
        showThinkingIndicator(msg.source, false);
        setContent(msg.source, msg.content, duration);
        setSourceStatus(msg.source, 'complete');

        if (msg.source === 'synthesis') {
          state.debating = false;
          enableForm(true);
          setStatus('Analysis complete!', 'success');
          // Auto-expand triage on completion
          if (!state.triageExpanded) {
            toggleTriage();
          }
        }
        break;

      case 'status':
        setStatus(msg.message);
        break;

      case 'error':
        state.isStreaming[msg.source] = false;
        showThinkingIndicator(msg.source, false);
        setSourceStatus(msg.source, 'error');
        if (['auth', 'system', 'debate'].includes(msg.source)) {
          setStatus(msg.message, 'error');
          state.debating = false;
          enableForm(true);
        }
        break;

      case 'auth_status':
        // Auth status handled silently
        break;
    }
  }

  // Show/hide thinking indicator
  function showThinkingIndicator(source, show) {
    const indicator = document.getElementById(`thinking-${source}`);
    if (indicator) {
      indicator.classList.toggle('active', show);
    }
  }

  // Update thinking preview during streaming
  function updateThinkingPreview(source) {
    const preview = document.getElementById(`thinking-preview-${source}`);
    if (preview && state.responses[source]) {
      // Show last ~200 chars of response as preview
      const text = state.responses[source];
      const previewText = text.length > 200 ? '...' + text.slice(-200) : text;
      preview.textContent = previewText;
    }
  }

  // UI helpers
  function setStatus(message, type = '') {
    statusText.textContent = message;
    const statusBar = document.getElementById('status-bar');
    statusBar.classList.remove('error', 'success');
    if (type) statusBar.classList.add(type);
  }

  function setConnectionStatus(connected) {
    connectionIndicator.classList.toggle('connected', connected);
    connectionIndicator.classList.toggle('disconnected', !connected);
  }

  function enableForm(enabled) {
    input.disabled = !enabled;
    submitBtn.disabled = !enabled || state.debating;
  }

  function setSourceStatus(source, status) {
    const el = document.getElementById(`status-${source}`);
    const pane = document.getElementById(`pane-${source}`);

    if (el) {
      el.textContent = status;
      el.className = source === 'synthesis' ? 'triage-status' : 'pane-status';
      if (status !== 'idle') el.classList.add(status);
    }

    if (pane) {
      pane.classList.remove('streaming', 'complete', 'error');
      if (status !== 'idle') pane.classList.add(status);
    }
  }

  function appendContent(source, chunk) {
    state.responses[source] += chunk;
    // Update thinking preview during streaming
    updateThinkingPreview(source);
  }

  function setContent(source, content, duration = 0) {
    state.responses[source] = content;
    renderFinalContent(source, duration);
  }

  // Render final content with collapsible thinking block
  function renderFinalContent(source, duration) {
    const contentEl = document.getElementById(`content-${source}`);
    const responseEl = document.getElementById(`response-${source}`);
    if (!contentEl || !responseEl) return;

    contentEl.classList.remove('empty');
    const text = state.responses[source];

    if (!text) {
      responseEl.innerHTML = '';
      contentEl.classList.add('empty');
      return;
    }

    // Create thinking block header
    const durationText = duration > 0 ? `${duration}s` : '';
    const thinkingBlock = `
      <div class="thinking-block collapsed" id="thinking-block-${source}">
        <div class="thinking-header" onclick="toggleThinkingBlock('${source}')">
          <svg class="thinking-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6 9 12 15 18 9"/>
          </svg>
          <div class="thinking-header-text">
            <span class="thinking-label">Thought for ${durationText}</span>
          </div>
        </div>
        <div class="thinking-content">
          <div class="thinking-text">${escapeHtml(text.slice(0, 500))}${text.length > 500 ? '...' : ''}</div>
        </div>
      </div>
    `;

    // Render the main response as markdown
    let responseHtml = '';
    try {
      responseHtml = marked.parse(text);
    } catch (e) {
      responseHtml = `<p>${escapeHtml(text)}</p>`;
    }

    responseEl.innerHTML = thinkingBlock + responseHtml;
    contentEl.scrollTop = contentEl.scrollHeight;
  }

  // Escape HTML for safe display
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Toggle completed thinking block
  window.toggleThinkingBlock = function(source) {
    const block = document.getElementById(`thinking-block-${source}`);
    if (block) {
      block.classList.toggle('collapsed');
    }
  };

  function clearAll() {
    ['claude', 'chatgpt', 'gemini', 'synthesis'].forEach(source => {
      state.responses[source] = '';
      state.thinkingStartTime[source] = null;
      state.isStreaming[source] = false;

      // Clear response content
      const responseEl = document.getElementById(`response-${source}`);
      if (responseEl) {
        responseEl.innerHTML = '';
      }

      // Clear thinking preview
      const previewEl = document.getElementById(`thinking-preview-${source}`);
      if (previewEl) {
        previewEl.textContent = '';
      }

      // Hide thinking indicator
      showThinkingIndicator(source, false);

      // Reset content container
      const content = document.getElementById(`content-${source}`);
      if (content) {
        content.classList.add('empty');
      }

      setSourceStatus(source, 'idle');
    });
    triageOverlay.classList.remove('has-new');
  }

  // Form submission
  form.addEventListener('submit', (e) => {
    e.preventDefault();
    const prompt = input.value.trim();
    if (!prompt || !state.connected || state.debating) return;

    clearAll();
    state.debating = true;
    enableForm(false);
    setStatus('Starting debate...');

    // Collapse triage for new debate
    if (state.triageExpanded) {
      toggleTriage();
    }

    state.ws.send(JSON.stringify({
      action: 'debate',
      prompt: prompt
    }));
  });

  // Copy buttons
  document.querySelectorAll('.copy-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const source = btn.dataset.copy;
      const text = state.responses[source];
      if (text) {
        navigator.clipboard.writeText(text).then(() => {
          btn.textContent = 'Copied!';
          btn.classList.add('copied');
          setTimeout(() => {
            btn.textContent = source === 'synthesis' ? 'Copy Analysis' : 'Copy';
            btn.classList.remove('copied');
          }, 1500);
        });
      }
    });
  });

  // Keyboard shortcut
  input.addEventListener('keydown', (e) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
      e.preventDefault();
      form.dispatchEvent(new Event('submit'));
    }
  });

  // Focus and connect
  input.focus();
  connect();

  // Handle URL params
  const params = new URLSearchParams(window.location.search);
  const promptParam = params.get('prompt');
  if (promptParam) {
    input.value = promptParam;
    const checkAndSubmit = () => {
      if (state.connected) {
        setTimeout(() => form.dispatchEvent(new Event('submit')), 500);
      } else {
        setTimeout(checkAndSubmit, 100);
      }
    };
    checkAndSubmit();
  }
  </script>
</body>
</html>
